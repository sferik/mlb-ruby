module MLB
  CLIENT: Client
  VERSION: Gem::Version

  class Error < StandardError
  end

  class ClientError < HTTPError
  end

  class BadGateway < ClientError
  end

  class BadRequest < ClientError
  end

  class ConnectionException < ClientError
  end

  class HTTPError < Error
    attr_reader response : Net::HTTPResponse
    attr_reader code : String

    def initialize: (response: Net::HTTPResponse) -> void
  end

  class Forbidden < ClientError
  end

  class GatewayTimeout < ClientError
  end

  class Gone < ClientError
  end

  class InternalServerError < ServerError
  end

  class NetworkError < Error
  end

  class NotAcceptable < ClientError
  end

  class NotFound < ClientError
  end

  class PayloadTooLarge < ClientError
  end

  class ServerError < HTTPError
  end

  class ServiceUnavailable < ServerError
  end

  class TooManyRedirects < Error
  end

  class TooManyRequests < ClientError
  end

  class Unauthorized < ClientError
  end

  class UnprocessableEntity < ClientError
  end

  class Connection
    DEFAULT_HOST: String
    DEFAULT_PORT: Integer
    DEFAULT_OPEN_TIMEOUT: Integer
    DEFAULT_READ_TIMEOUT: Integer
    DEFAULT_WRITE_TIMEOUT: Integer
    DEFAULT_DEBUG_OUTPUT: IO
    NETWORK_ERRORS: Array[(singleton(Errno::ECONNREFUSED) | singleton(Errno::ECONNRESET) | singleton(Net::OpenTimeout) | singleton(Net::ReadTimeout) | singleton(OpenSSL::SSL::SSLError))]

    @proxy_url: URI::Generic | String

    extend Forwardable

    attr_accessor open_timeout : Float | Integer
    attr_accessor read_timeout : Float | Integer
    attr_accessor write_timeout : Float | Integer
    attr_accessor debug_output : IO

    attr_reader proxy_uri: URI::Generic?
    attr_reader proxy_host : String?
    attr_reader proxy_port : Integer?
    attr_reader proxy_user : String?
    attr_reader proxy_pass : String?

    def initialize: (?open_timeout: Float | Integer, ?read_timeout: Float | Integer, ?write_timeout: Float | Integer, ?proxy_url: URI::Generic? | String?, ?debug_output: IO) -> void
    def proxy_url=: (URI::Generic | String proxy_url) -> void
    def perform: (request: Net::HTTPRequest) -> Net::HTTPResponse

    private
    def build_http_client: (?String host, ?Integer port) -> Net::HTTP
    def configure_http_client: (Net::HTTP http_client) -> Net::HTTP
  end

  class RequestBuilder
    HTTP_METHODS: Hash[Symbol, (singleton(Net::HTTP::Get) | singleton(Net::HTTP::Post) | singleton(Net::HTTP::Put) | singleton(Net::HTTP::Delete))]
    DEFAULT_HEADERS: Hash[String, String]

    def initialize: (?content_type: String, ?user_agent: String) -> void
    def build: (http_method: Symbol, uri: URI::Generic, ?body: String?, ?headers: Hash[String, String]) -> (Net::HTTPRequest)

    private
    def create_request: (http_method: Symbol, uri: URI::Generic, body: String?) -> (Net::HTTPRequest)
    def add_headers: (request: Net::HTTPRequest, headers: Hash[String, String]) -> void
    def escape_query_params: (URI::Generic uri) -> URI::Generic
  end

  class RedirectHandler
    DEFAULT_MAX_REDIRECTS: Integer

    attr_reader connection: Connection
    attr_reader request_builder: RequestBuilder
    attr_reader max_redirects: Integer
    def initialize: (?connection: Connection, ?request_builder: RequestBuilder, ?max_redirects: Integer) -> void
    def handle: (response: Net::HTTPResponse, request: Net::HTTPRequest, base_url: String, ?redirect_count: Integer) -> Net::HTTPResponse

    private
    def build_new_uri: (Net::HTTPResponse response, String base_url) -> URI::Generic
    def build_request: (Net::HTTPRequest request, URI::Generic new_uri, Integer response_code) -> Net::HTTPRequest
    def send_new_request: (URI::Generic new_uri, Net::HTTPRequest new_request) -> Net::HTTPResponse
  end

  class ErrorHandler
    ERROR_MAP: Hash[Integer, singleton(BadGateway) | singleton(BadRequest) | singleton(ConnectionException) | singleton(Forbidden) | singleton(GatewayTimeout) | singleton(Gone) | singleton(InternalServerError) | singleton(NotAcceptable) | singleton(NotFound) | singleton(PayloadTooLarge) | singleton(ServiceUnavailable) | singleton(TooManyRequests) | singleton(Unauthorized) | singleton(UnprocessableEntity)]
    JSON_CONTENT_TYPE_REGEXP: Regexp

    def parse: (response: Net::HTTPResponse) -> untyped

    private
    def error: (Net::HTTPResponse response) -> HTTPError
    def error_class: (Net::HTTPResponse response) -> (singleton(BadGateway) | singleton(BadRequest) | singleton(ConnectionException) | singleton(Forbidden) | singleton(GatewayTimeout) | singleton(Gone) | singleton(InternalServerError) | singleton(NotAcceptable) | singleton(NotFound) | singleton(PayloadTooLarge) | singleton(ServiceUnavailable) | singleton(TooManyRequests) | singleton(Unauthorized) | singleton(UnprocessableEntity))
    def json?: (Net::HTTPResponse response) -> bool
  end

  class Client
    DEFAULT_BASE_URL: String
    extend Forwardable
    @connection: Connection
    @request_builder: RequestBuilder
    @redirect_handler: RedirectHandler
    @error_handler: ErrorHandler

    attr_accessor base_url: String
    def initialize: (?base_url: String, ?open_timeout: Integer, ?read_timeout: Integer, ?write_timeout: Integer, ?debug_output: untyped, ?proxy_url: nil, ?max_redirects: Integer) -> void
    def get: (String endpoint, ?headers: Hash[String, String]) -> untyped
    def post: (String endpoint, ?String? body, ?headers: Hash[String, String]) -> untyped
    def put: (String endpoint, ?String? body, ?headers: Hash[String, String]) -> untyped
    def delete: (String endpoint, ?headers: Hash[String, String]) -> untyped

    private
    def execute_request: (:delete | :get | :post | :put http_method, String endpoint, ?body: String?, ?headers: Hash[String, String]) -> nil
  end

  attr_accessor effective_date: String
  attr_accessor player_id: String
  attr_accessor team_id: String

  class Team < Struct[untyped]
    attr_accessor team_id: String
    def self.new: -> void
    def self.all: (?season: Integer, ?sort_order: String, ?all_star: false) -> Array[Team]
    def roster: -> Array[Player]
  end

  class Transaction < Struct[untyped]
    attr_accessor player_id: String
    attr_accessor team_id: String
    def self.new: -> void
    def self.all: (?season: Integer, ?sort_order: String, ?all_star: false) -> Array[Team]
    def team: -> Team
    def player: -> Player
  end

  class Player < Struct[untyped]
    attr_accessor player_id: String
    def self.new: -> void
    def team: -> Team
  end
end
